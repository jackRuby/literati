== Literati ==
Literati is a literate programming library written in Ruby.

One of the big issues with development is how fast code
documentation becomes out of date, when it is written at all.

While programs are executed by computers, we write them mostly
for the benefit of other programmers, hence the proliferation of
high level languages such as Ruby and Python.

Literate programming is an attempt to solve this problem by 
tightly coupling the code to the documentation, and to help
programmers write clearer programs for each other first, and for
computers second.

Literate programming was pioneered by Donald Knuth, and while there
are a lot of software packages to tangle/weave literate programming
files, there's a wide variety of syntaxes for writing documents.

Literati attempts to keep the literate programming syntax as
close to regular text as possible, so you don't have to think
about how to format your programs and documentation.

Literati keeps out of your way so you can do what you do best:
write code.

== Class definition ==
The Literati class is the interface into the Literati programming
library. You can access it's functionality with the following switches:
- weave [-a, -d] [file, file, ...]
Weave takes optional arguments, which will control which kind of
documentation is generated
- tangle [file, file, ...]

== Weave ==
Weaving will parse the Literati source and will create documentation
from it. You can pass in some flags to control the documentation:
-a: This will generate API docs, which is any comment block tagged
with @api.
-d: This will generate long form documentation, which is any comment
block tagged with @doc.
Comment blocks can be tagged with both tags, but need to be tagged
with at least one.
@doc

def weave(document, mode)
  if mode == 'api'
  	return document.weave_api
  else
    return document.weave_doc
  end
end

== Tangle ==
Tangling will parse the Literati source and will create a source code
from it. Literati is language agnostic, and will attempt to preserve
whitespace. Code blocks must follow a documentation block.
The order you define sections doesn't matter, as there is a program
description section at the end of every Literati document that 
specifies the order the source code should be compiled.
@doc

def tangle(code)
  document.tangle
end

== Initialization ==

def initialization
	Parse command line options.
	Construct documents.
end

== Parse command line options ==
Go through the given command line arguments and set a bunch of 
options based on them.
The first argument should be a command, either 
@doc

ARGV.each_with_index do |arg, i|
  if i == 0
    if arg != 'weave' || arg != 'tangle'
      Fail on wrong command.
    end
    @command = arg
  elsif =~ '-'
  	@doc_style = 'api' if arg == '-a'
  	@doc_style = 'doc' if arg == '-d'
  end
  @files << arg
end

== Construct documents ==
In a loop, open the files passed in by the user and parse each
one into a document.

@files.each do |file|
  Read file.
  parse_document content
  Execute command.
end

== Read file ==
Read all the lines of a text file and store the lines as an array
@doc

lines = []
File.readlines(file).each { |line|
  lines << line
}

== Parse document ==
Split the document based on predefined header formats.
The headers are delimiters for blocks. Each header is
followed by a comment section and a code section.
The comment section is ended by the API token '@'
@doc

def parse_document(lines)
  block_start = 0
  block = nil
  lines.each_with_index do |line, i|
    if line =~ header_regex
      if !block.nil?
        block.lines = lines.slice[block_start..i - 1]
        blocks << block
      end
      block_start = i
      block = Section.new
    end
  end
end

== Variable declaration ==
This is where we define variables
@doc

header_regex = /^==\s([^=]*)\s?==/
blocks = []

== Execute command ==
Based on the command passed in by the user, call the appropriate
weave/tangle method
@doc

weaveif @command == 'weave'

== Shebang ==
#! /usr/bin/env ruby

== @literati.rb ==
Shebang.
class Literati
  Intialization.
  Weave.
  Tangle.
end