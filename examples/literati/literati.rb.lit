== Literati ==
Literati is a literate programming library written in Ruby.

One of the big issues with development is how fast code
documentation becomes out of date, when it is written at all.

While programs are executed by computers, we write them mostly
for the benefit of other programmers, hence the proliferation of
high level languages such as Ruby and Python.

Literate programming is an attempt to solve this problem by 
tightly coupling the code to the documentation, and to help
programmers write clearer programs for each other first, and for
computers second.

Literate programming was pioneered by Donald Knuth, and while there
are a lot of software packages to tangle/weave literate programming
files, there's a wide variety of syntaxes for writing documents.

Literati attempts to keep the literate programming syntax as
close to regular text as possible, so you don't have to think
about how to format your programs and documentation.

Literati keeps out of your way so you can do what you do best:
write code.

== Usage ==
You can access it's functionality with the following switches:
- all [file, file, ...]
All takes optional arguments, which will control which files are operated
on. It will perform both a weave and a tangle on each file.
- weave [file, file, ...]
Weave takes optional arguments, which will control which kind of
documentation is generated
- tangle [file, file, ...]

== Weave ==
Weaving will parse the Literati source and will create documentation
from it. 
By default, it will tangle every .lit file it can find in the current
directory recursively.
Alternatively, you can give it a filename and it will weave just that
individual file.

In the future we will support custom flags to control which coment blocks
go into the documentation generated.

== Tangle ==
Tangling will parse the Literati source and will create a source code
from it. Literati is language agnostic, and will attempt to preserve
whitespace. Code blocks must follow a documentation block.
The order you define sections doesn't matter, as there is a program
description section at the end of every Literati document that 
specifies the order the source code should be compiled.

== Gather documents ==
Check the arguments passed in. If no file is passed in,
recursively gather a list of paths to tangle or weave.
Otherwise, just set it to the passed in file path.
If you pass in a file, it will operate on a single file. If you pass in a
path, it will operate recursively on that path.
-
if ARGV.length < 1
  abort "Usage: literati.rb [tangle|weave] [input_file]"
end

# sanity check on mode
mode = ARGV.shift
abort "I don't know how to '#{mode}'" unless Parser::Program.method_defined? mode

# gather paths
input_files = []
ARGV << './' if ARGV.empty?
ARGV.each do |arg|
  next if not File.exists?(arg)
  if !File.directory?(arg)
    input_files << arg if File.basename(arg) =~ /\.lit$/i
  else
    Find.find(arg) do |path|
      next if File.directory? path
      input_files << path if File.basename(path) =~ /\.lit$/i
    end
  end
end

abort "Couldn't find path/s '#{ARGV.join(', ')}'. Are you sure it's correct?" if input_files.empty?

puts "#{mode.chop}ing:\n#{input_files.join("\n")}"
-

== Glue ==
-
#! /usr/bin/env ruby

$: << '.' unless $:.include?('.')
require 'find'
require 'lib/tokenizer'
require 'lib/lexer'
require 'lib/linker'

Gather documents.

input_files.each do |file|
  tokens = Parser::tokenize file
  program, statements = Parser::lex tokens
  statements = Parser::link statements
  program.send(mode.to_sym, statements)
end
-

== @literati.rb ==
Glue.