== Program ==
The Program class is perhaps misnamed. It represents a file that is required to be
written to disk. This includes code files (as the result of a tangle) and doc
files (as the result of a weave).
The Program class is responsible for implementing weaving and tangling.

== Convert title to filename ==
Take a title that declares a file and turn the title into a usable filename.
We use this when the Program instance is initialized
-
def convert_title_to_filename(title)
  @filename = title.gsub(/[=|\s|@]/, '')
end
-

== Initialize ==
Take an array of lines that form a program definition.
The first line will be the filename, so convert that first.
Then copy all lines to an instance variable.
Set up a base output directory, currently hardcoded to 'output', then set up sub directories
for source ('src') and documentation ('doc')
-
def initialize(lines)
  @refs = []
  convert_title_to_filename lines.first
  lines.shift
  @refs = lines.dup
  @base_output_dir = File.join(Dir.pwd, 'output')
  @base_tangle_dir = File.join(@base_output_dir, 'src')
  @base_weave_dir = File.join(@base_output_dir, 'doc')
end
-

== Create output dir ==
Create the output directory if it doesn't already exist
-
Dir.mkdir(@base_output_dir) if not File.exists?(@base_output_dir)
-

== Weave ==
It is a assumed that the documentation is written in order, after all, a Literati document
is intended to be human readable first, and then able to be compiled down into programming
code that a computer can execute.
Right now we hard code the formatter, however that could be a metadata field, the and we can
allow the user to just compile HTML doc, or textile doc, or whatever.
We can add custom formatters so that people can extend the Literati with a custom formatting.
-
def weave(statements, path = nil)
  require 'lib/formatter/text' # this is hard coded, but should be passed in
  Create output dir.
  Dir.mkdir(@base_weave_dir) if not File.exists?(@base_weave_dir)
  filename = File.join(@base_weave_dir, @filename.gsub(/\.rb/,''))
  comment = Formatter::format(statements)
  File.open("#{filename}.txt", 'w') {|f| f.write(comment) } unless comment.nil?
end
-

== Build code map ==
Build another code map. For details, see the Build Code Map section of the linker.
TODO: Refactor this into a module wide method, or something.
-
def build_code_map(statements)
  code_map = {}
  statements.each do |statement|
    next if !(statement.respond_to?(:get_code) && statement.respond_to?(:get_title))
    code_map[statement.get_title] = statement
  end
  code_map
end
-

== Build directory structure ==
Code files can be organized into a file structure by including a full path in the
program definition block. This allows literati to potentially write a different
source tree than it is stored in.
This method will build the dir structure based on the name passed in
-
def build_dir_structure(name, base)
  # handle both Windows and *nix file structures
  dirs = name.split(/[\/\\]/)
  current_path = ""
  dirs.each_with_index do |dir, i|
    break if i == dirs.length - 1 # skip the last one as it's a filename
    path = File.join(base, current_path, dir)
    Dir.mkdir(path) unless File.exists?(path)
    current_path = File.join(current_path, dir)
  end
end
-

== Tangle ==
Build a code map from a list of statements given. Then take the @refs global that
holds a list of ordered literati block references, and slowly build the file to
be written out. Then write out the file at the filename we converted earlier.
-
def tangle(statements, path = nil)
  Create output dir.
  Dir.mkdir(@base_tangle_dir) if not File.exists?(@base_tangle_dir)
  build_dir_structure(@filename, @base_tangle_dir)
  filename = File.join(@base_tangle_dir, @filename)
  buffer = []
  map = build_code_map(statements)
  @refs.each do |ref|
    buffer.concat map[ref.gsub('.', '').strip].get_code
  end
  File.open(filename, 'w') do |file|
    buffer.each { |line| file.write("#{line}\n") }
  end
end
-

== The class ==
-
class Program
  Initialize.
  Weave.
  Tangle.
  private
  Convert title to filename.
  Build code map.
  Build directory structure.
end
-

== The module ==
-
module Parser
  The class.
end
-

== @lib/program.rb ==
The module.